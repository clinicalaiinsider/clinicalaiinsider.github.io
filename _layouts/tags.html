---
layout: default
---

<header class="tags-header">
    <h1 class="tags-title">{{ page.title | default: "Tags" }}</h1>
    <p class="tags-subtitle">Browse topics by category</p>
    <div class="search-wrapper">
        <input type="search" id="tag-search" class="tag-search" placeholder="Search tags..." autocomplete="off">
        <span class="search-icon">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="M21 21l-4.35-4.35"></path>
            </svg>
        </span>
    </div>
    <div class="search-results" id="search-results" hidden>
        <div class="matched-category" id="matched-category"></div>
        <div class="matched-tags" id="matched-tags"></div>
    </div>
</header>

<section class="tags-container">
    <div class="categories-grid" id="categories-grid">
        <!-- Categories will be rendered by JavaScript -->
    </div>

    <div class="no-results" id="no-results" hidden>
        <p>No tags found matching your search.</p>
    </div>

    <div class="posts-panel" id="posts-panel" hidden>
        <div class="panel-header">
            <div class="panel-title-group">
                <span class="panel-category" id="panel-category"></span>
                <span class="panel-separator">:</span>
                <span class="panel-tag" id="panel-tag"></span>
            </div>
            <button class="close-btn" id="close-btn" aria-label="Close panel">&times;</button>
        </div>
        <ul class="posts-list" id="posts-list"></ul>
    </div>
</section>

<!-- Category Taxonomy Definition -->
<script type="application/json" id="category-taxonomy">
{
    "OHDSI": {
        "color": "ohdsi",
        "icon": "üî¨",
        "description": "OHDSI ecosystem tools and methods",
        "tags": ["ohdsi", "atlas", "achilles", "webapi", "broadsea", "plp", "patient-level-prediction", "cohort-definitions", "observational-research", "hades", "athena"]
    },
    "Data Standards": {
        "color": "data",
        "icon": "üìä",
        "description": "Healthcare data models and ETL",
        "tags": ["omop-cdm", "omop", "cdm", "etl", "data-quality", "synthea", "data-standards", "data standards"]
    },
    "Terminology": {
        "color": "fhir",
        "icon": "üìñ",
        "description": "Clinical vocabularies and coding systems",
        "tags": ["loinc", "snomed-ct", "snomed ct", "rxnorm", "icd", "cpt", "clinical-terminologies", "vocabulary"]
    },
    "Interoperability": {
        "color": "fhir",
        "icon": "üîó",
        "description": "Healthcare data exchange standards",
        "tags": ["fhir", "hl7", "cda", "ehr", "healthcare-data", "healthcare data", "lis", "clinical-workflow", "clinical workflow", "interoperability"]
    },
    "Clinical AI": {
        "color": "nlp",
        "icon": "ü§ñ",
        "description": "Machine learning and NLP in healthcare",
        "tags": ["nlp", "healthcare-ai", "biobert", "machine-learning", "deep-learning", "ner", "clinical-nlp", "lasso-regression", "healthcare-analytics"]
    },
    "Development": {
        "color": "python",
        "icon": "üíª",
        "description": "Technical tools and programming",
        "tags": ["python", "docker", "postgresql", "streamlit", "r-programming"]
    },
    "Research": {
        "color": "default",
        "icon": "üìë",
        "description": "Clinical research methodology",
        "tags": ["real-world-evidence", "real-world-data", "clinical-research", "clinical-informatics", "healthcare-analytics"]
    },
    "Clinical Domains": {
        "color": "default",
        "icon": "üè•",
        "description": "Disease areas and specialties",
        "tags": ["type-2-diabetes", "gi-hemorrhage", "cardiology", "oncology"]
    },
    "Learning": {
        "color": "tutorial",
        "icon": "üìö",
        "description": "Tutorials and educational content",
        "tags": ["tutorial", "guide", "how-to", "resources"]
    }
}
</script>

<!-- Posts Data -->
<script type="application/json" id="tags-data">
{
  {% for tag in site.tags %}
  "{{ tag[0] | slugify }}": {
    "name": "{{ tag[0] }}",
    "posts": [
      {% for post in tag[1] %}
      {
        "title": {{ post.title | jsonify }},
        "url": "{{ post.url | relative_url }}",
        "date": "{{ post.date | date: '%b %d' }}"
      }{% unless forloop.last %},{% endunless %}
      {% endfor %}
    ]
  }{% unless forloop.last %},{% endunless %}
  {% endfor %}
}
</script>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const taxonomy = JSON.parse(document.getElementById('category-taxonomy').textContent);
    const tagsData = JSON.parse(document.getElementById('tags-data').textContent);
    const searchInput = document.getElementById('tag-search');
    const searchResults = document.getElementById('search-results');
    const matchedCategory = document.getElementById('matched-category');
    const matchedTags = document.getElementById('matched-tags');
    const categoriesGrid = document.getElementById('categories-grid');
    const postsPanel = document.getElementById('posts-panel');
    const panelCategory = document.getElementById('panel-category');
    const panelTag = document.getElementById('panel-tag');
    const postsList = document.getElementById('posts-list');
    const closeBtn = document.getElementById('close-btn');
    const noResults = document.getElementById('no-results');

    // Build reverse lookup: tag -> category
    const tagToCategory = {};
    Object.entries(taxonomy).forEach(([category, data]) => {
        data.tags.forEach(tag => {
            tagToCategory[tag.toLowerCase()] = category;
        });
    });

    // Get actual tags from posts data
    const actualTags = Object.keys(tagsData);

    // Group actual tags by category
    function getTagsByCategory() {
        const grouped = {};
        Object.keys(taxonomy).forEach(cat => grouped[cat] = []);

        actualTags.forEach(tagSlug => {
            const tagName = tagsData[tagSlug].name.toLowerCase();
            let found = false;

            for (const [category, data] of Object.entries(taxonomy)) {
                if (data.tags.some(t => t.toLowerCase() === tagName || t.toLowerCase() === tagSlug)) {
                    if (!grouped[category].find(t => t.slug === tagSlug)) {
                        grouped[category].push({
                            slug: tagSlug,
                            name: tagsData[tagSlug].name,
                            count: tagsData[tagSlug].posts.length
                        });
                    }
                    found = true;
                    break;
                }
            }

            // If not found in any category, add to appropriate default
            if (!found) {
                // Try to match partial names
                const tagLower = tagName.toLowerCase();
                if (tagLower.includes('ohdsi') || tagLower.includes('atlas') || tagLower.includes('achilles')) {
                    grouped['OHDSI'].push({ slug: tagSlug, name: tagsData[tagSlug].name, count: tagsData[tagSlug].posts.length });
                } else if (tagLower.includes('omop') || tagLower.includes('cdm') || tagLower.includes('etl')) {
                    grouped['Data Standards'].push({ slug: tagSlug, name: tagsData[tagSlug].name, count: tagsData[tagSlug].posts.length });
                } else if (tagLower.includes('fhir') || tagLower.includes('hl7') || tagLower.includes('ehr')) {
                    grouped['Interoperability'].push({ slug: tagSlug, name: tagsData[tagSlug].name, count: tagsData[tagSlug].posts.length });
                } else if (tagLower.includes('nlp') || tagLower.includes('ai') || tagLower.includes('ml')) {
                    grouped['Clinical AI'].push({ slug: tagSlug, name: tagsData[tagSlug].name, count: tagsData[tagSlug].posts.length });
                } else {
                    grouped['Research'].push({ slug: tagSlug, name: tagsData[tagSlug].name, count: tagsData[tagSlug].posts.length });
                }
            }
        });

        return grouped;
    }

    const tagsByCategory = getTagsByCategory();

    // Render categories
    function renderCategories() {
        categoriesGrid.innerHTML = Object.entries(taxonomy)
            .filter(([cat]) => tagsByCategory[cat] && tagsByCategory[cat].length > 0)
            .map(([category, data]) => {
                const tags = tagsByCategory[category];
                const totalPosts = tags.reduce((sum, t) => sum + t.count, 0);

                return `
                    <div class="category-card cat-${data.color}" data-category="${category}">
                        <div class="category-header">
                            <span class="category-icon">${data.icon}</span>
                            <span class="category-name">${category}</span>
                            <span class="category-count">${totalPosts}</span>
                        </div>
                        <p class="category-desc">${data.description}</p>
                        <div class="category-tags">
                            ${tags.slice(0, 6).map(tag =>
                                `<button class="sub-tag tag-${data.color}" data-tag="${tag.slug}" data-category="${category}">${tag.name}<sup>${tag.count}</sup></button>`
                            ).join('')}
                            ${tags.length > 6 ? `<span class="more-tags">+${tags.length - 6} more</span>` : ''}
                        </div>
                    </div>
                `;
            }).join('');

        // Add click handlers to sub-tags
        document.querySelectorAll('.sub-tag').forEach(btn => {
            btn.addEventListener('click', function(e) {
                e.stopPropagation();
                showPosts(this.dataset.tag, this.dataset.category);
            });
        });

        // Add click handlers to category cards
        document.querySelectorAll('.category-card').forEach(card => {
            card.addEventListener('click', function() {
                const category = this.dataset.category;
                showCategoryPosts(category);
            });
        });
    }

    // Search functionality
    searchInput.addEventListener('input', function(e) {
        const query = e.target.value.toLowerCase().trim();

        if (!query) {
            searchResults.hidden = true;
            categoriesGrid.style.display = '';
            noResults.hidden = true;
            return;
        }

        // Find matching tags
        const matches = [];
        actualTags.forEach(tagSlug => {
            const tagName = tagsData[tagSlug].name.toLowerCase();
            if (tagName.includes(query) || tagSlug.includes(query)) {
                // Find category for this tag
                let category = 'Research';
                for (const [cat, data] of Object.entries(taxonomy)) {
                    if (data.tags.some(t => t.toLowerCase() === tagName || t.toLowerCase() === tagSlug)) {
                        category = cat;
                        break;
                    }
                }
                matches.push({
                    slug: tagSlug,
                    name: tagsData[tagSlug].name,
                    count: tagsData[tagSlug].posts.length,
                    category: category,
                    color: taxonomy[category]?.color || 'default'
                });
            }
        });

        if (matches.length === 0) {
            searchResults.hidden = true;
            categoriesGrid.style.display = 'none';
            noResults.hidden = false;
            return;
        }

        noResults.hidden = true;
        categoriesGrid.style.display = 'none';
        searchResults.hidden = false;

        // Group matches by category
        const byCategory = {};
        matches.forEach(m => {
            if (!byCategory[m.category]) byCategory[m.category] = [];
            byCategory[m.category].push(m);
        });

        // Render search results
        matchedCategory.innerHTML = Object.keys(byCategory).map(cat =>
            `<span class="result-category cat-${taxonomy[cat]?.color || 'default'}">${taxonomy[cat]?.icon || 'üìÅ'} ${cat}</span>`
        ).join('');

        matchedTags.innerHTML = matches.map(m =>
            `<button class="result-tag tag-${m.color}" data-tag="${m.slug}" data-category="${m.category}">
                ${m.name}<sup>${m.count}</sup>
            </button>`
        ).join('');

        // Add click handlers to result tags
        document.querySelectorAll('.result-tag').forEach(btn => {
            btn.addEventListener('click', function() {
                showPosts(this.dataset.tag, this.dataset.category);
            });
        });
    });

    // Show posts for a specific tag
    function showPosts(tagSlug, category) {
        const tagInfo = tagsData[tagSlug];
        if (!tagInfo) return;

        const catData = taxonomy[category];
        panelCategory.textContent = category;
        panelCategory.className = `panel-category cat-text-${catData?.color || 'default'}`;
        panelTag.textContent = `${tagInfo.name} (${tagInfo.posts.length})`;

        postsList.innerHTML = tagInfo.posts.map(post =>
            `<li><a href="${post.url}">${post.title}</a> <span class="date">${post.date}</span></li>`
        ).join('');

        postsPanel.hidden = false;
        history.replaceState(null, null, `#${tagSlug}`);

        setTimeout(() => {
            postsPanel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }, 50);
    }

    // Show all posts for a category
    function showCategoryPosts(category) {
        const tags = tagsByCategory[category];
        if (!tags || tags.length === 0) return;

        const catData = taxonomy[category];

        // Collect all unique posts from this category
        const allPosts = [];
        const seenUrls = new Set();

        tags.forEach(tag => {
            tagsData[tag.slug].posts.forEach(post => {
                if (!seenUrls.has(post.url)) {
                    seenUrls.add(post.url);
                    allPosts.push(post);
                }
            });
        });

        panelCategory.textContent = category;
        panelCategory.className = `panel-category cat-text-${catData?.color || 'default'}`;
        panelTag.textContent = `All (${allPosts.length} posts)`;

        postsList.innerHTML = allPosts.map(post =>
            `<li><a href="${post.url}">${post.title}</a> <span class="date">${post.date}</span></li>`
        ).join('');

        postsPanel.hidden = false;

        setTimeout(() => {
            postsPanel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }, 50);
    }

    // Close panel
    closeBtn.addEventListener('click', function() {
        postsPanel.hidden = true;
        history.replaceState(null, null, window.location.pathname);
    });

    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && !postsPanel.hidden) {
            postsPanel.hidden = true;
        }
        if (e.key === '/' && document.activeElement !== searchInput) {
            e.preventDefault();
            searchInput.focus();
        }
    });

    // Handle URL hash
    if (window.location.hash) {
        const tagSlug = window.location.hash.slice(1);
        if (tagsData[tagSlug]) {
            // Find category for this tag
            let category = 'Research';
            const tagName = tagsData[tagSlug].name.toLowerCase();
            for (const [cat, data] of Object.entries(taxonomy)) {
                if (data.tags.some(t => t.toLowerCase() === tagName || t.toLowerCase() === tagSlug)) {
                    category = cat;
                    break;
                }
            }
            setTimeout(() => showPosts(tagSlug, category), 100);
        }
    }

    // Initial render
    renderCategories();
});
</script>

<style>
/* Header */
.tags-header {
    text-align: center;
    padding: 40px 24px 20px;
    max-width: var(--max-width);
    margin: 0 auto;
}

.tags-title {
    font-family: var(--font-serif);
    font-size: 2rem;
    font-weight: 600;
    margin-bottom: 6px;
}

.tags-subtitle {
    color: var(--color-text-muted);
    font-size: 0.95rem;
    margin-bottom: 20px;
}

/* Search */
.search-wrapper {
    position: relative;
    max-width: 400px;
    margin: 0 auto 16px;
}

.tag-search {
    width: 100%;
    padding: 12px 14px 12px 40px;
    border: 1px solid var(--color-border);
    border-radius: 8px;
    font-size: 0.9rem;
    font-family: var(--font-sans);
    background: var(--color-bg-card);
    color: var(--color-text);
    transition: all 0.2s;
}

.tag-search:focus {
    outline: none;
    border-color: var(--color-accent);
    box-shadow: 0 0 0 3px rgba(196, 93, 58, 0.1);
}

.search-icon {
    position: absolute;
    left: 14px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--color-text-muted);
}

/* Search Results */
.search-results {
    max-width: 600px;
    margin: 0 auto;
    text-align: left;
    padding: 16px;
    background: var(--color-bg-card);
    border: 1px solid var(--color-border);
    border-radius: 8px;
}

.matched-category {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 12px;
}

.result-category {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 0.8rem;
    font-weight: 600;
}

.matched-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
}

.result-tag {
    padding: 5px 10px;
    border: none;
    border-radius: 16px;
    font-size: 0.75rem;
    cursor: pointer;
    transition: all 0.15s;
}

.result-tag:hover {
    transform: scale(1.05);
}

.result-tag sup {
    font-size: 0.6rem;
    opacity: 0.7;
    margin-left: 2px;
}

/* Categories Container */
.tags-container {
    max-width: 900px;
    margin: 0 auto;
    padding: 0 24px 40px;
}

/* Categories Grid */
.categories-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 16px;
    margin-bottom: 20px;
}

/* Category Card */
.category-card {
    background: var(--color-bg-card);
    border: 1px solid var(--color-border);
    border-radius: 12px;
    padding: 20px;
    cursor: pointer;
    transition: all 0.2s;
}

.category-card:hover {
    border-color: var(--color-text-muted);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.08);
}

.category-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
}

.category-icon {
    font-size: 1.25rem;
}

.category-name {
    font-weight: 600;
    font-size: 1rem;
    flex: 1;
}

.category-count {
    background: var(--color-border);
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 0.75rem;
    color: var(--color-text-muted);
}

.category-desc {
    font-size: 0.8rem;
    color: var(--color-text-muted);
    margin-bottom: 12px;
    line-height: 1.4;
}

.category-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
}

.sub-tag {
    padding: 4px 8px;
    border: none;
    border-radius: 12px;
    font-size: 0.7rem;
    cursor: pointer;
    transition: all 0.15s;
}

.sub-tag:hover {
    transform: scale(1.05);
}

.sub-tag sup {
    font-size: 0.55rem;
    opacity: 0.7;
    margin-left: 1px;
}

.more-tags {
    font-size: 0.7rem;
    color: var(--color-text-muted);
    padding: 4px 8px;
}

/* Category Color Themes */
.cat-ohdsi { border-left: 4px solid var(--color-ohdsi); }
.cat-ohdsi .category-count { background: var(--color-ohdsi-light); color: var(--color-ohdsi); }

.cat-fhir { border-left: 4px solid var(--color-fhir); }
.cat-fhir .category-count { background: var(--color-fhir-light); color: var(--color-fhir); }

.cat-data { border-left: 4px solid var(--color-data); }
.cat-data .category-count { background: var(--color-data-light); color: var(--color-data); }

.cat-nlp { border-left: 4px solid var(--color-nlp); }
.cat-nlp .category-count { background: var(--color-nlp-light); color: var(--color-nlp); }

.cat-python { border-left: 4px solid var(--color-python); }
.cat-python .category-count { background: var(--color-python-light); color: var(--color-python); }

.cat-tutorial { border-left: 4px solid var(--color-tutorial); }
.cat-tutorial .category-count { background: var(--color-tutorial-light); color: var(--color-tutorial); }

.cat-default { border-left: 4px solid var(--color-border-dark); }

/* Tag Colors */
.tag-ohdsi { background: var(--color-ohdsi-light); color: var(--color-ohdsi); }
.tag-ohdsi:hover { background: var(--color-ohdsi); color: white; }

.tag-fhir { background: var(--color-fhir-light); color: var(--color-fhir); }
.tag-fhir:hover { background: var(--color-fhir); color: white; }

.tag-data { background: var(--color-data-light); color: var(--color-data); }
.tag-data:hover { background: var(--color-data); color: white; }

.tag-nlp { background: var(--color-nlp-light); color: var(--color-nlp); }
.tag-nlp:hover { background: var(--color-nlp); color: white; }

.tag-python { background: var(--color-python-light); color: var(--color-python); }
.tag-python:hover { background: var(--color-python); color: white; }

.tag-tutorial { background: var(--color-tutorial-light); color: var(--color-tutorial); }
.tag-tutorial:hover { background: var(--color-tutorial); color: white; }

.tag-default { background: var(--color-bg-alt); color: var(--color-text-secondary); }
.tag-default:hover { background: var(--color-border); color: var(--color-text); }

/* Category Text Colors */
.cat-text-ohdsi { color: var(--color-ohdsi); }
.cat-text-fhir { color: var(--color-fhir); }
.cat-text-data { color: var(--color-data); }
.cat-text-nlp { color: var(--color-nlp); }
.cat-text-python { color: var(--color-python); }
.cat-text-tutorial { color: var(--color-tutorial); }
.cat-text-default { color: var(--color-text-muted); }

/* Result Category Pills */
.result-category.cat-ohdsi { background: var(--color-ohdsi-light); color: var(--color-ohdsi); }
.result-category.cat-fhir { background: var(--color-fhir-light); color: var(--color-fhir); }
.result-category.cat-data { background: var(--color-data-light); color: var(--color-data); }
.result-category.cat-nlp { background: var(--color-nlp-light); color: var(--color-nlp); }
.result-category.cat-python { background: var(--color-python-light); color: var(--color-python); }
.result-category.cat-tutorial { background: var(--color-tutorial-light); color: var(--color-tutorial); }
.result-category.cat-default { background: var(--color-bg-alt); color: var(--color-text-secondary); }

/* No Results */
.no-results {
    text-align: center;
    padding: 40px 20px;
    color: var(--color-text-muted);
}

/* Posts Panel */
.posts-panel {
    background: var(--color-bg-card);
    border: 1px solid var(--color-border);
    border-radius: 12px;
    padding: 20px;
    margin-top: 16px;
    animation: slideDown 0.2s ease-out;
}

.posts-panel[hidden] { display: none; }

@keyframes slideDown {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}

.panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
    padding-bottom: 12px;
    border-bottom: 1px solid var(--color-border);
}

.panel-title-group {
    display: flex;
    align-items: center;
    gap: 8px;
}

.panel-category {
    font-weight: 600;
    font-size: 0.9rem;
}

.panel-separator {
    color: var(--color-text-muted);
}

.panel-tag {
    font-size: 0.9rem;
    color: var(--color-text);
}

.close-btn {
    background: none;
    border: none;
    font-size: 1.5rem;
    cursor: pointer;
    color: var(--color-text-muted);
    padding: 4px 8px;
    border-radius: 4px;
    transition: all 0.15s;
}

.close-btn:hover {
    background: var(--color-border);
    color: var(--color-text);
}

/* Posts List */
.posts-list {
    list-style: disc;
    padding-left: 20px;
    margin: 0;
}

.posts-list li {
    padding: 6px 0;
    font-size: 0.85rem;
    line-height: 1.4;
}

.posts-list li a {
    color: var(--color-text);
    text-decoration: none;
    transition: color 0.15s;
}

.posts-list li a:hover {
    color: var(--color-accent);
    text-decoration: underline;
}

.posts-list .date {
    color: var(--color-text-muted);
    font-size: 0.75rem;
    margin-left: 8px;
}

/* Responsive */
@media (max-width: 600px) {
    .categories-grid {
        grid-template-columns: 1fr;
    }

    .category-card {
        padding: 16px;
    }
}
</style>
